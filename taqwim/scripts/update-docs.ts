import { pathToFileURL, fileURLToPath } from 'node:url';
import * as path from 'node:path';
import fse from 'fs-extra';
import { globbySync } from 'globby';
import type { RuleDataOptional, RuleDefaultOptions, RuleOneOfSchema } from '@taqwim/types';
import cliProgress from 'cli-progress';
import chalk from 'chalk';

type TestFileData = {
	description: string;
	content: string;
};

type JsonData = {
	description: string;
	expected: number;
	expectedCallback?: (result: any) => void;
};

type TestData = {
	correct: TestFileData[];
	incorrect: TestFileData[];
};

type GlobalTestData = {
	[key: string]: TestData;
};

type Presets = {
	[key: string]: RuleDataOptional[];
};

type CliOption = {
	alias?: string;
	type?: string;
	description?: string;
	default?: string;
	choices?: string[];
};

const currentDirectory = fileURLToPath(new URL('.', import.meta.url)).replaceAll('\\', '/');
const extensionDirectory = path.posix.join(currentDirectory, '..', '..');

// create progress bar defaults
const progressBar = new cliProgress.SingleBar({
	format: `Updating Docs   ${chalk.magentaBright('{bar}')}    ${chalk.magenta('{percentage}%')}    ({value}/{total})`,
	barCompleteChar: '>',
	barIncompleteChar: '-',
	hideCursor: true,
});

/**
 * Update rules documentation.
 *
 * This class will take all the rules in the rules folder and do the following:
 * - Get the rule name and description from the rule file inside docs/rules-desc
 * - Get test cases from the rule file inside taqwim/tests/rules
 * - Generate a markdown file for the rule
 * - Write the markdown file to docs/rules
 * - Generate a markdown for each preset which includes all the rules under that preset
 */
export class UpdateRulesDocumentation {
	private rulesList: Record<string, unknown> = {};

	private rulesFiles: string[];

	private rulesFolder: string;

	private currentRule!: RuleDataOptional;

	constructor(rulesFolder: string, rulesFiles: string[]) {
		this.rulesFolder = rulesFolder;
		this.rulesFiles = rulesFiles;
	}

	/**
	 * Generate file header to show that file is auto generated
	 *
	 * @return {string} Header string
	 */
	getFileGeneratedHeader(): string {
		const date = new Date();
		const year = date.getFullYear();
		const month = date.getMonth() + 1;
		const day = date.getDate();

		return `<!--- This file is auto generated. Do not edit this file manually. ${year}-${month}-${day} ---> \n\n`;
	}

	/**
	 * Get rule file
	 *
	 * @param  {string}         ruleFile Rule file name
	 * @return {boolean|object}          Rule object or false if file does not exist
	 */
	async getRuleFile(ruleFile: string) {
		const filePath = path.posix.join('.', 'src', this.rulesFolder, ruleFile);

		if (!fse.existsSync(filePath)) {
			return false;
		}

		// import file and get rule name
		const rule = await import(pathToFileURL(filePath).href);
		return rule.default();
	}

	/**
	 * Get the path for rule description from docs/rules-desc
	 *
	 * @param  {string}         preset   Preset name
	 * @param  {string}         ruleName Rule name
	 * @return {boolean|string}          Rule desc path for markdown or false if file does not exist
	 */
	getDescFile(preset: string, ruleName: string): boolean | string {
		const ruleDescFilePath = path.posix.join(extensionDirectory, 'docs', 'rules-desc', preset, `${ruleName}.md`);

		if (!fse.existsSync(ruleDescFilePath)) {
			return false;
		}

		return `<!--@include: @/rules-desc/${preset}/${ruleName}.md -->`;
	}

	/**
	 * Load test meta for rule
	 *
	 * @param  {string}  ruleTestDirectory Directory of rule test
	 * @param  {string}  ruleName          Rule name
	 * @return {Promise}                   Meta data
	 */
	async loadTestMetaData(ruleTestDirectory: string, ruleName: string) {
		// Load meta data from json in same directory
		const metaFileJS = path.posix.join(ruleTestDirectory, 'data.js');
		const metaFileJson = path.posix.join(ruleTestDirectory, 'data.json');

		const metaFileJSExists = fse.pathExistsSync(metaFileJS);
		if (!metaFileJSExists && !fse.pathExistsSync(metaFileJson)) {
			throw new Error(`No data.js or data.json files found for ${ruleName}`);
		}

		let metaFileData: Record<string, Record<string, JsonData>>;
		if (metaFileJSExists) {
			const importJs = await import(metaFileJS);
			metaFileData = importJs.default;
		} else {
			metaFileData = await fse.readJSON(metaFileJson);
		}

		return metaFileData;
	}

	/**
	 * Get test related to rule
	 *
	 * @param  {string}          ruleName Rule file name
	 * @return {Promise|boolean}          Test data or false if no tests found
	 */
	async getTestsData(ruleName: string): Promise<GlobalTestData> {
		// Find the test cases in the taqwim/tests/folderName folder
		const ruleTestDirectory = path.posix.join('test', this.rulesFolder, ruleName);

		if (!fse.existsSync(ruleTestDirectory)) {
			return {
				default: {
					correct: [],
					incorrect: [],
				},
			};
		}

		// Get all php files in the test directory
		const phpFiles = globbySync('**/*.php', {
			absolute: false,
			gitignore: false,
			cwd: ruleTestDirectory,
		});

		// Loop through PHP files and add extra data for easier retrieval
		const phpFilesWithData = phpFiles.reduce((accumulator, phpFileName) => {
			const phpFilePath = path.posix.join(ruleTestDirectory, phpFileName);
			const phpFileKey = phpFileName.replace('.php', '');
			const phpFileData = fse.readFileSync(phpFilePath, 'utf8');

			accumulator[phpFileKey] = {
				content: phpFileData,
			};

			return accumulator;
		}, {} as Record<string, { content: string }>);

		// Get meta data from json file
		const metaFileData = await this.loadTestMetaData(ruleTestDirectory, ruleName);

		// Loop through meta data nad match with PHP files
		const results: GlobalTestData = {};

		Object.entries(metaFileData).forEach(([group, groupData]) => {
			const correctEntries: TestFileData[] = [];
			const incorrectEntries: TestFileData[] = [];

			Object.entries(groupData).forEach(([fileName, testData]) => {
				const metaInfo = phpFilesWithData[fileName];
				if (!metaInfo) {
					throw new Error(`No meta info found for ${fileName}`);
				}

				// check if the test is correct or incorrect
				const isInCorrect = /incorrect/u.test(fileName);

				const entryData = {
					...metaInfo,
					fileName,
					description: testData.description,
				};

				if (isInCorrect) {
					incorrectEntries.push(entryData);
				} else {
					correctEntries.push(entryData);
				}
			});

			results[group] = {
				correct: correctEntries,
				incorrect: incorrectEntries,
			};
		});

		return results;
	}

	/**
	 * Prepare examples data for markdown
	 *
	 * @param  {string}         type      Type of example (correct, incorrect)
	 * @param  {TestFileData[]} testsData Test data
	 * @return {string}                   Examples markdown
	 */
	prepareExamplesData(type: string, testsData: TestFileData[]): string {
		return testsData.map((test: TestFileData) => {
			const exampleData: string[] = [];
			exampleData.push(
				`:::${type} ${test.description}`,
				'```php',
				test.content,
				'\n```',
				':::\n\n'
			);
			return exampleData.join('\n');
		}).join('\n');
	}

	/**
	 * Output examples markdown
	 *
	 * @param  {TestData} testsData Test data
	 * @param  {string}   testGroup Test group
	 * @return {string}             Examples markdown
	 */
	outputExamples(testsData: TestData, testGroup: string): string {
		let ruleMarkdown = '';

		let correctExamples = '';
		let incorrectExamples = '';
		let option = 'options';
		let heading = '## Examples {#default-examples}\n\n';

		if (testGroup !== 'default') {
			heading = `### ${testGroup} {#${testGroup}-examples}\n\n`;
			option = 'option';
		}

		if (testsData.correct.length > 0 || testsData.incorrect.length > 0) {
			ruleMarkdown += heading;
		}

		if (testsData.correct.length > 0) {
			correctExamples = this.prepareExamplesData('correct', testsData.correct);

			ruleMarkdown += `- Examples of ***correct*** code for this rule using ${testGroup} ${option}\n\n`;
			ruleMarkdown += `${correctExamples}\n\n`;
		}

		if (testsData.incorrect.length > 0) {
			incorrectExamples = this.prepareExamplesData('incorrect', testsData.incorrect);

			ruleMarkdown += `- Examples of ***incorrect*** code for this rule using ${testGroup} ${option}\n\n`;
			ruleMarkdown += `${incorrectExamples}\n\n`;
		}

		return ruleMarkdown;
	}

	/**
	 * Get markdown for oneOf schema
	 *
	 * @param  {RuleOneOfSchema[]} oneOf OneOf schema
	 * @return {string}                  Markdown
	 */
	getOneOfMarkdown(oneOf: RuleOneOfSchema[]): string {
		const joinValues = oneOf.map((item) => {
			return `\`${item.const}\`{data-desc=${JSON.stringify(item.description)}}`;
		}).join(', ');

		return `Possible values: ${joinValues} {.option-possible-values}\n\n`;
	}

	/**
	 * Get options and output related markdown
	 *
	 * @return {string} Options markdown
	 */
	outputOptionsMarkdown(): string {
		const { defaultOptions, name: ruleName } = this.currentRule;

		if (defaultOptions === undefined) {
			return '';
		}

		let ruleMarkdown = '';
		ruleMarkdown += '## Options\n\n';

		/* eslint complexity: ["warn", 8] */
		Object.keys(defaultOptions).forEach((optionName) => {
			const option: RuleDefaultOptions = defaultOptions[optionName];

			if (option.description === undefined) {
				throw new Error(`Description for option \`${optionName}\` is missing in \`${ruleName}\` rule`);
			}

			if (option.enum !== undefined) {
				throw new Error(`Use oneOf instead of enum in option \`${optionName}\` in \`${ruleName}\` rule`);
			}

			const defaultValue = Array.isArray(option.default) ? `[${option.default.join(', ')}]` : option.default;

			ruleMarkdown += `#### ${optionName} {.option-title}\n\n`;
			ruleMarkdown += `${option.description} {.option-description} \n\n`;
			ruleMarkdown += `Type: \`${option.type}\` {.option-type} \n\n`;
			ruleMarkdown += `Default: \`${defaultValue}\` {.option-default}\n\n`;

			if (option.oneOf !== undefined) {
				ruleMarkdown += this.getOneOfMarkdown(option.oneOf);
			}

			if (option.items === undefined) {
				return;
			}

			if (option.items.enum !== undefined) {
				throw new Error(`Use oneOf instead of enum in \`items\` key inside \`${optionName}\` option in \`${ruleName}\` rule`);
			}

			if (option.items.oneOf === undefined) {
				throw new Error(`Missing \`oneOf\` key inside \`items\` key inside \`${optionName}\` option in \`${ruleName}\` rule`);
			}

			ruleMarkdown += this.getOneOfMarkdown(option.items.oneOf);
		});

		ruleMarkdown += '\n';

		return ruleMarkdown;
	}

	/**
	 * Create a page for each preset to include the list of
	 * all rules under that preset
	 *
	 * @param  {Presets} presets Presets object
	 * @return {Promise}         A promise that resolves when all presets are created
	 */
	outputPresetList(presets: Presets): Promise<any> {
		return Object.keys(presets).reduce(
			async (previousPromise: Promise<any>, presetName: string) => {
				await previousPromise;

				const presetRules = presets[presetName];

				let presetMarkdown = `# ${presetName} Preset{.preset-rules} \n`;
				presetMarkdown += 'Rules under this preset:\n';

				presetRules.forEach((rule) => {
					const { meta, name: ruleName } = rule;

					presetMarkdown += `#### [**${ruleName}**](./${meta.preset}/${ruleName}.md)`;
					if (meta.fixable === true) {
						presetMarkdown += '<Badge type="tip" text="fixable" />';
					}

					presetMarkdown += '\n';
					presetMarkdown += `${meta.description}\n\n`;
				});

				const presetMarkdownFile = path.posix.join(extensionDirectory, 'docs', 'rules', `${presetName}.md`);
				await fse.outputFile(presetMarkdownFile, presetMarkdown);
			}, Promise.resolve()
		);
	}

	/**
	 * Output cli options markdown
	 *
	 * @return {Promise} A promise that resolves when the markdown file is created
	 */
	async outputCliOptions(): Promise<any> {
		const cliOptionsFilePath = path.posix.join(extensionDirectory, 'taqwim', 'src', 'cli', 'options.ts');

		// import content
		const cliOptions = await import(pathToFileURL(cliOptionsFilePath).href);
		const markdownOutput: string[] = [this.getFileGeneratedHeader()];
		Object.entries(cliOptions.default).forEach(([optionName, optionData]) => {
			const {
				description,
				type,
				alias,
				default: defaultValue,
				choices,
			} = optionData as CliOption;
			const defaultValueOutput = Array.isArray(defaultValue) ? `[${defaultValue.join(', ')}]` : defaultValue;

			const title = [`--${optionName}`];
			if (alias) {
				title.push(`-${alias}`);
			}

			markdownOutput.push(
				`\n#### ${title.join(', ')} {.option-title}`,
				`${description} {.option-description}`,
				`Type: \`${type}\` {.option-type}`
			);

			if (defaultValue !== undefined) {
				markdownOutput.push(`Default: \`${defaultValueOutput}\` {.option-default}`);
			}

			if (choices !== undefined) {
				markdownOutput.push(`Choices: \`${choices.join(', ')}\` {.option-choices}`);
			}
		});

		// Write markdown file
		const cliOptionsMarkdownFile = path.posix.join(extensionDirectory, 'docs', 'cli-options.md');
		return fse.outputFile(cliOptionsMarkdownFile, markdownOutput.join('\n\n'));
	}

	async start(cleanDestination = false) {
		progressBar.start(this.rulesFiles.length, 0);

		// Clean docs/rules folder
		if (cleanDestination) {
			await fse.emptyDir(path.posix.join(extensionDirectory, 'docs', 'rules'));
		}
		const presets: Presets = {};

		await this.rulesFiles.reduce(async (previousPromise: Promise<any>, ruleFile: string) => {
			await previousPromise;
			this.currentRule = await this.getRuleFile(ruleFile);
			const { meta, name: ruleName } = this.currentRule;

			// add rule to preset object
			presets[meta.preset] ??= [];
			presets[meta.preset].push(this.currentRule);

			// Find the rule description in the docs/rules-desc folder
			const ruleDescPath = this.getDescFile(meta.preset, ruleName);
			const shortDescription = meta.description ?? '';
			const testsData = await this.getTestsData(ruleName);

			// Generate markdown file
			let ruleMarkdown = this.getFileGeneratedHeader();
			ruleMarkdown += `# ${ruleName}`;
			if (meta.fixable === true) {
				ruleMarkdown += '<Badge type="tip" text="fixable" />';
			}
			ruleMarkdown += '\n\n';
			ruleMarkdown += `${shortDescription}\n\n`;

			if (ruleDescPath !== false) {
				ruleMarkdown += `${ruleDescPath}\n\n`;
			}

			ruleMarkdown += this.outputOptionsMarkdown();

			Object.keys(testsData).forEach((group) => {
				// ignore 'extra-tests' group
				if (group === 'extra-tests') {
					return;
				}

				const groupData = testsData[group];
				const examplesOutput = this.outputExamples(groupData, group);
				if (examplesOutput !== '') {
					ruleMarkdown += examplesOutput;
				}
			});

			// Write markdown file
			const ruleMarkdownFile = path.posix.join(extensionDirectory, 'docs', 'rules', meta.preset, `${ruleName}.md`);
			await fse.outputFile(ruleMarkdownFile, ruleMarkdown);

			// update progress bar
			progressBar.increment();
		}, Promise.resolve());

		// Create a page for each preset
		await this.outputPresetList(presets);

		await this.outputCliOptions();

		progressBar.stop();
	}
}